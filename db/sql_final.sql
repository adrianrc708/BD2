

-----------------------------------------------------------------------------
-- 1. LIMPIEZA Y PREPARACIÓN (Opcional, por si reinicias)
-----------------------------------------------------------------------------
ALTER SESSION SET "_ORACLE_SCRIPT" = TRUE;
-- CREATE TABLESPACE ts_tienda DATAFILE 'C:\app\...\ts_tienda.dbf' SIZE 20M AUTOEXTEND ON NEXT 5M MAXSIZE UNLIMITED;

-- Creación de Usuario
CREATE USER adrian IDENTIFIED BY adrian_pwd DEFAULT TABLESPACE ts_tienda QUOTA UNLIMITED ON ts_tienda;

GRANT CONNECT, RESOURCE TO adrian;
GRANT CREATE VIEW, CREATE TRIGGER, CREATE SEQUENCE, CREATE PROCEDURE TO adrian;

ALTER SESSION SET CURRENT_SCHEMA = ADRIAN;
-----------------------------------------------------------------------------
-- 2. TABLAS (Incluyendo la de Auditoría para el tema de Triggers)
-----------------------------------------------------------------------------
CREATE TABLE clientes (
  id_cliente NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  nombre VARCHAR2(50) NOT NULL,
  apellido VARCHAR2(50),
  dni VARCHAR2(15) UNIQUE,
  correo VARCHAR2(80),
  fecha_registro DATE DEFAULT SYSDATE
);

CREATE TABLE empleados (
  id_empleado NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  nombre VARCHAR2(50) NOT NULL,
  apellido VARCHAR2(50),
  cargo VARCHAR2(30),
  salario NUMBER(10,2),
  fecha_contrato DATE DEFAULT SYSDATE,
  usuario_app VARCHAR2(50) UNIQUE,
  password_hash VARCHAR2(64)
);

CREATE TABLE productos (
  id_producto NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  nombre VARCHAR2(80) NOT NULL,
  categoria VARCHAR2(40),
  descripcion VARCHAR2(200),
  marca VARCHAR2(50),
  modelo VARCHAR2(50),
  precio NUMBER(10,2) DEFAULT 0,
  stock NUMBER(7) DEFAULT 0,
  proveedor VARCHAR2(80),
  fecha_ingreso DATE DEFAULT SYSDATE,
  fecha_vencimiento DATE,
  estado VARCHAR2(20) DEFAULT 'Activo',
  ubicacion VARCHAR2(80)
);

CREATE TABLE ventas (
  id_venta NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  id_cliente NUMBER REFERENCES clientes(id_cliente),
  id_empleado NUMBER REFERENCES empleados(id_empleado),
  fecha_venta DATE DEFAULT SYSDATE,
  total NUMBER(12,2) DEFAULT 0
);

CREATE TABLE detalle_venta (
  id_detalle NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  id_venta NUMBER REFERENCES ventas(id_venta) ON DELETE CASCADE,
  id_producto NUMBER REFERENCES productos(id_producto),
  cantidad NUMBER(7),
  subtotal NUMBER(12,2)
);

-- Tabla para demostrar el tema "10 Triggers.pdf" (Auditoría)
CREATE TABLE historial_precios (
  id_historial NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  id_producto NUMBER,
  precio_anterior NUMBER(10,2),
  precio_nuevo NUMBER(10,2),
  usuario_modifico VARCHAR2(50),
  fecha_cambio DATE DEFAULT SYSDATE
);

COMMIT;

-----------------------------------------------------------------------------
-- 3. TRIGGERS (Nivel Avanzado: Auditoría y Validación Cruzada)
-----------------------------------------------------------------------------

-- Trigger 1: Control de Stock (Lógica de Negocio básica)
CREATE OR REPLACE TRIGGER trg_control_stock
BEFORE INSERT ON detalle_venta
FOR EACH ROW
DECLARE
  v_stock productos.stock%TYPE;
BEGIN
  SELECT stock INTO v_stock FROM productos WHERE id_producto = :NEW.id_producto;
  IF v_stock IS NULL THEN
    RAISE_APPLICATION_ERROR(-20001,'Producto no existe: '||:NEW.id_producto);
  ELSIF v_stock < :NEW.cantidad THEN
    RAISE_APPLICATION_ERROR(-20002,'Stock insuficiente para producto: '||:NEW.id_producto);
  ELSE
    UPDATE productos SET stock = stock - :NEW.cantidad WHERE id_producto = :NEW.id_producto;
  END IF;
END;
/

-- Trigger 2: Salario Mínimo (Validación de datos)
CREATE OR REPLACE TRIGGER trg_salario_minimo
BEFORE INSERT OR UPDATE ON empleados
FOR EACH ROW
BEGIN
  IF :NEW.salario IS NOT NULL AND :NEW.salario < 1025 THEN
    RAISE_APPLICATION_ERROR(-20003,'Salario menor al mínimo (1025).');
  END IF;
END;
/

-- Trigger 3: Actualiza Total Venta (Automatización)
CREATE OR REPLACE TRIGGER trg_actualiza_total
AFTER INSERT ON detalle_venta
FOR EACH ROW
BEGIN
  UPDATE ventas SET total = NVL(total,0) + :NEW.subtotal WHERE id_venta = :NEW.id_venta;
END;
/

-- Trigger 4: Auditoría de Precios (Cumple con tema "Auditoría" y variables :OLD/:NEW)
CREATE OR REPLACE TRIGGER trg_auditoria_precios
AFTER UPDATE OF precio ON productos
FOR EACH ROW
BEGIN
  IF :OLD.precio != :NEW.precio THEN
    INSERT INTO historial_precios (
      id_producto, precio_anterior, precio_nuevo, usuario_modifico
    ) VALUES (
      :NEW.id_producto, :OLD.precio, :NEW.precio, USER
    );
  END IF;
END;
/

-- Trigger 5: Bloqueo de Vencidos (Validación compleja con SELECT interno)
CREATE OR REPLACE TRIGGER trg_bloqueo_vencidos
BEFORE INSERT ON detalle_venta
FOR EACH ROW
DECLARE
  v_fecha_venc DATE;
BEGIN
  SELECT fecha_vencimiento INTO v_fecha_venc
  FROM productos WHERE id_producto = :NEW.id_producto;

  IF v_fecha_venc IS NOT NULL AND v_fecha_venc < TRUNC(SYSDATE) THEN
    RAISE_APPLICATION_ERROR(-20005, 'ERROR CRÍTICO: Producto VENCIDO. Venta bloqueada.');
  END IF;
END;
/
COMMIT;

-----------------------------------------------------------------------------
-- 4. PAQUETE DE GESTIÓN (Con EXCEPCIÓN PROPIA - Tema "11 Excepciones.pdf")
-----------------------------------------------------------------------------
CREATE OR REPLACE PACKAGE pkg_gestion_productos AUTHID CURRENT_USER AS
  PROCEDURE sp_registrar (p_nombre VARCHAR2, p_categoria VARCHAR2, p_descripcion VARCHAR2, p_marca VARCHAR2, p_modelo VARCHAR2, p_precio NUMBER, p_stock NUMBER, p_proveedor VARCHAR2, p_fecha_venc DATE, p_estado VARCHAR2, p_ubicacion VARCHAR2);
  PROCEDURE sp_modificar (p_id NUMBER, p_nombre VARCHAR2, p_categoria VARCHAR2, p_descripcion VARCHAR2, p_marca VARCHAR2, p_modelo VARCHAR2, p_precio NUMBER, p_stock NUMBER, p_proveedor VARCHAR2, p_fecha_venc DATE, p_estado VARCHAR2, p_ubicacion VARCHAR2);
  PROCEDURE sp_eliminar (p_id NUMBER);
  -- Navegación
  PROCEDURE sp_get_primero (p_id OUT NUMBER, p_nombre OUT VARCHAR2, p_marca OUT VARCHAR2, p_stock OUT NUMBER);
  PROCEDURE sp_get_ultimo (p_id OUT NUMBER, p_nombre OUT VARCHAR2, p_marca OUT VARCHAR2, p_stock OUT NUMBER);
  PROCEDURE sp_get_siguiente (p_id_actual IN NUMBER, p_id OUT NUMBER, p_nombre OUT VARCHAR2, p_marca OUT VARCHAR2, p_stock OUT NUMBER);
  PROCEDURE sp_get_anterior (p_id_actual IN NUMBER, p_id OUT NUMBER, p_nombre OUT VARCHAR2, p_marca OUT VARCHAR2, p_stock OUT NUMBER);
END pkg_gestion_productos;
/

CREATE OR REPLACE PACKAGE BODY pkg_gestion_productos AS

  PROCEDURE sp_registrar (
    p_nombre VARCHAR2, p_categoria VARCHAR2, p_descripcion VARCHAR2,
    p_marca VARCHAR2, p_modelo VARCHAR2, p_precio NUMBER, p_stock NUMBER,
    p_proveedor VARCHAR2, p_fecha_venc DATE, p_estado VARCHAR2, p_ubicacion VARCHAR2
  ) AS
    -- [NIVEL EXPERTO] Declaración de Excepción Definida por el Usuario
    e_producto_duplicado EXCEPTION;
    v_conteo NUMBER;
  BEGIN
    -- Validamos si el nombre ya existe
    SELECT COUNT(*) INTO v_conteo FROM productos WHERE UPPER(nombre) = UPPER(p_nombre);

    IF v_conteo > 0 THEN
      -- Lanzamos la excepción manualmente
      RAISE e_producto_duplicado;
    END IF;

    INSERT INTO productos (nombre,categoria,descripcion,marca,modelo,precio,stock,proveedor,fecha_vencimiento,estado,ubicacion)
    VALUES (p_nombre,p_categoria,p_descripcion,p_marca,p_modelo,p_precio,p_stock,p_proveedor,p_fecha_venc,p_estado,p_ubicacion);
    COMMIT;

  EXCEPTION
    -- [NIVEL EXPERTO] Manejo de la Excepción Propia
    WHEN e_producto_duplicado THEN
       RAISE_APPLICATION_ERROR(-20010, 'Error de Negocio: El producto "'||p_nombre||'" ya existe en el catálogo.');
    WHEN OTHERS THEN
       RAISE_APPLICATION_ERROR(-20011, 'Error desconocido: ' || SQLERRM);
  END sp_registrar;

  -- Resto de procedimientos estándar...
  PROCEDURE sp_modificar (p_id NUMBER, p_nombre VARCHAR2, p_categoria VARCHAR2, p_descripcion VARCHAR2, p_marca VARCHAR2, p_modelo VARCHAR2, p_precio NUMBER, p_stock NUMBER, p_proveedor VARCHAR2, p_fecha_venc DATE, p_estado VARCHAR2, p_ubicacion VARCHAR2) AS
  BEGIN UPDATE productos SET nombre=p_nombre, categoria=p_categoria, descripcion=p_descripcion, marca=p_marca, modelo=p_modelo, precio=p_precio, stock=p_stock, proveedor=p_proveedor, fecha_vencimiento=p_fecha_venc, estado=p_estado, ubicacion=p_ubicacion WHERE id_producto = p_id; COMMIT; END sp_modificar;

  PROCEDURE sp_eliminar (p_id NUMBER) AS BEGIN DELETE FROM productos WHERE id_producto = p_id; COMMIT; END sp_eliminar;

  PROCEDURE sp_get_primero (p_id OUT NUMBER, p_nombre OUT VARCHAR2, p_marca OUT VARCHAR2, p_stock OUT NUMBER) AS BEGIN SELECT id_producto, nombre, marca, stock INTO p_id, p_nombre, p_marca, p_stock FROM productos ORDER BY id_producto ASC FETCH FIRST 1 ROWS ONLY; EXCEPTION WHEN NO_DATA_FOUND THEN p_id := NULL; END;
  PROCEDURE sp_get_ultimo (p_id OUT NUMBER, p_nombre OUT VARCHAR2, p_marca OUT VARCHAR2, p_stock OUT NUMBER) AS BEGIN SELECT id_producto, nombre, marca, stock INTO p_id, p_nombre, p_marca, p_stock FROM productos ORDER BY id_producto DESC FETCH FIRST 1 ROWS ONLY; EXCEPTION WHEN NO_DATA_FOUND THEN p_id := NULL; END;
  PROCEDURE sp_get_siguiente (p_id_actual IN NUMBER, p_id OUT NUMBER, p_nombre OUT VARCHAR2, p_marca OUT VARCHAR2, p_stock OUT NUMBER) AS BEGIN SELECT id_producto, nombre, marca, stock INTO p_id, p_nombre, p_marca, p_stock FROM productos WHERE id_producto > p_id_actual ORDER BY id_producto ASC FETCH FIRST 1 ROWS ONLY; EXCEPTION WHEN NO_DATA_FOUND THEN p_id := NULL; END;
  PROCEDURE sp_get_anterior (p_id_actual IN NUMBER, p_id OUT NUMBER, p_nombre OUT VARCHAR2, p_marca OUT VARCHAR2, p_stock OUT NUMBER) AS BEGIN SELECT id_producto, nombre, marca, stock INTO p_id, p_nombre, p_marca, p_stock FROM productos WHERE id_producto < p_id_actual ORDER BY id_producto DESC FETCH FIRST 1 ROWS ONLY; EXCEPTION WHEN NO_DATA_FOUND THEN p_id := NULL; END;

END pkg_gestion_productos;
/


-----------------------------------------------------------------------------
-- 5. PAQUETE DE REPORTES (OPTIMIZADO CON SYS_REFCURSOR)
-----------------------------------------------------------------------------
CREATE OR REPLACE PACKAGE pkg_reportes AS
  PROCEDURE rep_ventas_por_mes (p_cursor OUT SYS_REFCURSOR);
  PROCEDURE rep_productos_stock_bajo (p_limite IN NUMBER, p_cursor OUT SYS_REFCURSOR);
  PROCEDURE rep_productos_mas_vendidos (p_cursor OUT SYS_REFCURSOR);
  PROCEDURE rep_valor_inventario (p_cursor OUT SYS_REFCURSOR);
  PROCEDURE rep_auditoria_cambios (p_cursor OUT SYS_REFCURSOR);
  PROCEDURE rep_mejores_clientes (p_cursor OUT SYS_REFCURSOR);       -- Reporte 6
  PROCEDURE rep_empleados_ingresos (p_cursor OUT SYS_REFCURSOR);     -- Reporte 7
  PROCEDURE rep_ventas_por_categoria (p_cursor OUT SYS_REFCURSOR);   -- Reporte 8
  PROCEDURE rep_productos_sin_ventas (p_cursor OUT SYS_REFCURSOR);   -- Reporte 9 (Usa LEFT JOIN)
  PROCEDURE rep_resumen_estadistico (p_mes IN VARCHAR2 DEFAULT NULL, p_id_empleado IN NUMBER DEFAULT NULL, p_cursor OUT SYS_REFCURSOR);
END pkg_reportes;
/

CREATE OR REPLACE PACKAGE BODY pkg_reportes AS

  PROCEDURE rep_ventas_por_mes (p_cursor OUT SYS_REFCURSOR) IS
  BEGIN
    OPEN p_cursor FOR
      SELECT TO_CHAR(fecha_venta, 'YYYY-MM') AS mes, SUM(total) AS total_mes
      FROM ventas
      GROUP BY TO_CHAR(fecha_venta, 'YYYY-MM')
      ORDER BY mes DESC;
  END rep_ventas_por_mes;

  PROCEDURE rep_productos_stock_bajo (p_limite IN NUMBER, p_cursor OUT SYS_REFCURSOR) IS
  BEGIN
    OPEN p_cursor FOR
      SELECT id_producto, nombre, stock
      FROM productos
      WHERE stock <= p_limite
      ORDER BY stock ASC;
  END rep_productos_stock_bajo;

  PROCEDURE rep_productos_mas_vendidos (p_cursor OUT SYS_REFCURSOR) IS
  BEGIN
    OPEN p_cursor FOR
      SELECT p.nombre, SUM(d.cantidad) AS total
      FROM productos p
      JOIN detalle_venta d ON p.id_producto = d.id_producto
      GROUP BY p.nombre
      ORDER BY total DESC;
  END rep_productos_mas_vendidos;

  PROCEDURE rep_valor_inventario (p_cursor OUT SYS_REFCURSOR) IS
  BEGIN
    OPEN p_cursor FOR
      SELECT categoria, COUNT(*) as items, SUM(stock) as stock_total, SUM(precio * stock) as valor_total
      FROM productos
      WHERE stock > 0
      GROUP BY categoria
      ORDER BY valor_total DESC;
  END rep_valor_inventario;

  PROCEDURE rep_auditoria_cambios (p_cursor OUT SYS_REFCURSOR) IS
  BEGIN
    OPEN p_cursor FOR
      SELECT p.nombre, h.precio_anterior, h.precio_nuevo, h.fecha_cambio, h.usuario_modifico
      FROM historial_precios h
      JOIN productos p ON h.id_producto = p.id_producto
      ORDER BY h.fecha_cambio DESC;
  END rep_auditoria_cambios;

  PROCEDURE rep_mejores_clientes (p_cursor OUT SYS_REFCURSOR) IS
  BEGIN
    OPEN p_cursor FOR
      SELECT c.nombre, c.apellido, -- DEVUELVE 4 COLUMNAS
             COUNT(v.id_venta) as cantidad_compras,
             NVL(SUM(v.total), 0) as total_gastado
      FROM clientes c
      JOIN ventas v ON c.id_cliente = v.id_cliente
      GROUP BY c.id_cliente, c.nombre, c.apellido
      ORDER BY total_gastado DESC
      FETCH FIRST 10 ROWS ONLY;
  END rep_mejores_clientes;

  -- 7. Rendimiento Empleados (Demuestra JOIN con tabla EMPLEADOS)
  PROCEDURE rep_empleados_ingresos (p_cursor OUT SYS_REFCURSOR) IS
  BEGIN
    OPEN p_cursor FOR
      SELECT e.nombre, e.apellido, -- DEVUELVE 4 COLUMNAS
             COUNT(v.id_venta) as ventas_realizadas,
             NVL(SUM(v.total), 0) as dinero_generado
      FROM empleados e
      JOIN ventas v ON e.id_empleado = v.id_empleado
      GROUP BY e.id_empleado, e.nombre, e.apellido
      ORDER BY dinero_generado DESC;
  END rep_empleados_ingresos;

  -- 8. Ventas por Categoría (Análisis de Producto)
  PROCEDURE rep_ventas_por_categoria (p_cursor OUT SYS_REFCURSOR) IS
  BEGIN
    OPEN p_cursor FOR
      SELECT p.categoria,
             COUNT(d.id_detalle) as items_vendidos,
             NVL(SUM(d.subtotal), 0) as total_ingresos
      FROM productos p
      JOIN detalle_venta d ON p.id_producto = d.id_producto
      GROUP BY p.categoria
      ORDER BY total_ingresos DESC;
  END rep_ventas_por_categoria;

  -- 9. Productos "Hueso" (Demuestra LEFT JOIN - Productos que existen pero nadie compra)
  PROCEDURE rep_productos_sin_ventas (p_cursor OUT SYS_REFCURSOR) IS
  BEGIN
    OPEN p_cursor FOR
      SELECT p.nombre, p.stock, p.categoria
      FROM productos p
      LEFT JOIN detalle_venta d ON p.id_producto = d.id_producto
      WHERE d.id_detalle IS NULL -- El truco del Left Join
      ORDER BY p.stock DESC;
  END rep_productos_sin_ventas;

  -- 10. Resumen Estadístico (Funciones de Agregación Globales)
  PROCEDURE rep_resumen_estadistico (
    p_mes IN VARCHAR2 DEFAULT NULL,
    p_id_empleado IN NUMBER DEFAULT NULL,
    p_cursor OUT SYS_REFCURSOR
  ) IS
    v_ambito VARCHAR2(50);
  BEGIN
-- 1. Determinar el Ámbito (para la columna 'ambito' del reporte)
    IF p_id_empleado IS NOT NULL THEN
        -- Se busca el nombre del empleado para darle contexto al reporte
        SELECT 'Empleado: ' || e.nombre || ' ' || e.apellido INTO v_ambito FROM empleados e WHERE id_empleado = p_id_empleado;
    ELSIF p_mes IS NOT NULL THEN
        v_ambito := 'Mes: ' || p_mes;
    ELSE
        v_ambito := 'Global';
    END IF;

-- 2. Abrir el cursor aplicando los filtros opcionales
    OPEN p_cursor FOR
      SELECT v_ambito as ambito,
             ROUND(AVG(total), 2) as ticket_promedio,
             MAX(total) as venta_maxima,
             MIN(total) as venta_minima,
             COUNT(*) as total_transacciones
      FROM ventas
      WHERE 1=1
-- Filtro por Empleado
        AND (p_id_empleado IS NULL OR id_empleado = p_id_empleado)
-- Filtro por Mes/Año
        AND (p_mes IS NULL OR TO_CHAR(fecha_venta, 'YYYY-MM') = p_mes);
  EXCEPTION
    WHEN NO_DATA_FOUND THEN
-- Si no se encuentra el empleado o no hay ventas, devuelve valores en cero
      v_ambito := 'Sin Datos / ' || v_ambito;
      OPEN p_cursor FOR
        SELECT v_ambito as ambito, 0, 0, 0, 0 FROM DUAL;
    WHEN OTHERS THEN
      RAISE_APPLICATION_ERROR(-20020, 'Error en rep_resumen_estadistico: ' || SQLERRM);
  END rep_resumen_estadistico;

END pkg_reportes;
/
COMMIT;

-----------------------------------------------------------------------------
-- 6. DATOS INICIALES DEL SISTEMA
-----------------------------------------------------------------------------

-- 1. Cliente Genérico (Necesario para ventas rápidas sin registro)
INSERT INTO clientes (nombre, apellido, dni, correo)
VALUES ('Público', 'General', '00000000', 'sin_correo@tienda.com');

-- 2. Primer Usuario Administrador (Super Admin)
-- Usuario: ADMIN
-- Contraseña: 1234 (Hash SHA256 precalculado)
INSERT INTO empleados (nombre, apellido, cargo, salario, usuario_app, password_hash)
VALUES ('Super', 'Admin', 'Administrador', 5000, 'ADMIN', '03ac674216f3e15c761ee1a5e255f067953623c8b388b4459e13f978d7c846f4');

COMMIT;
